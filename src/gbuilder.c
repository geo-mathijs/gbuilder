#include <postgres.h>
#include <catalog/pg_type.h>
#include <fmgr.h>
#include <funcapi.h>
#include <liblwgeom.h>
#include <utils/array.h>
#include "gbuilder.h"

PG_MODULE_MAGIC;

Datum concave_hull(PG_FUNCTION_ARGS);
Datum concave_hull_finalfn(PG_FUNCTION_ARGS);

PG_FUNCTION_INFO_V1(concave_hull);
Datum concave_hull(PG_FUNCTION_ARGS) {
    ArrayIterator iterator;
    ArrayType *array;
    Datum value;
    GSERIALIZED *result;
    LWMPOLY * lwmpoly;
    LWPOINT *lwpoint;
    LWPOLY *lwpoly;
    POINT2D *points;
    POINT4D p;
    bool isnull;
    float8 alpha;
    int i, j, k;
    int nelems;
    int npoints;
    int srid = 4326;
    multipolygon_t *mp;
    size_t ret_size = 0;
    tri_t *tri;

    /* Grab the function args */
    array = PG_GETARG_ARRAYTYPE_P(0);
    alpha = PG_GETARG_FLOAT8(1);
    nelems = ArrayGetNItems(ARR_NDIM(array), ARR_DIMS(array));

    /* No point in doing anything at this stage */
    if (nelems == 0)
        PG_RETURN_NULL();

    /*
     * Alloc 3 extra in advance. This is needed for the triangulation as
     * it adds a bounding triangle to the existing array.
     */
    points = palloc((sizeof(POINT2D) * nelems) + (sizeof(POINT2D) * 3));
    npoints = 0;

    /* Extract every point from the geometry array */
    iterator = array_create_iterator(array, 0, NULL);
    while (array_iterate(iterator, &value, &isnull)) {
        GSERIALIZED *pglwgeom;

        if (isnull)
            continue;

        pglwgeom = (GSERIALIZED *) DatumGetPointer(value);
        if (gserialized_get_type(pglwgeom) != POINTTYPE)
            continue;

        /*
         * Geometry array contains individual geometries instead of a POINTARRAY.
         * We extract every point as its own entity and copy over the data to an
         * internal array. Because of the basic usage of points at this stage it
         * is a normal array instead of the official POINTARRAY struct.
         */
        lwpoint = lwgeom_as_lwpoint(lwgeom_from_gserialized(pglwgeom));
        memcpy(&(points[npoints++]), getPoint_internal(lwpoint->point, 0), ptarray_point_size(lwpoint->point));
        lwgeom_free(lwpoint_as_lwgeom(lwpoint));
    }
    array_free_iterator(iterator);

    /* Nothing useful in the geometry array */
    if (npoints == 0)
        PG_RETURN_NULL();

    /* Internal geometry types */
    mp = (multipolygon_t *) palloc0(sizeof(multipolygon_t));
    tri = (tri_t *) palloc0(sizeof(tri_t));

    /* Call the robust predicate library to initialize the epsilon */
    exactinit();

    /*
     * Compute the delaunay triangulation for the set of points that
     * were extracted from the geometry array. This will add three
     * additional points (bounding triangle), so it is expected that
     * the points array can store these.
     *
     * Note that the triangulation relies on the robust predicates library
     * for roundoff errors. The epsilon that is used by the library needs
     * to be initialized beforehand by exactinit(), as this determines the
     * true precision cut-off.
     */
    triangulate(points, npoints, tri, srid);

    /*
     * The faces that are generated by the triangulation are used to find
     * the actual concave hull. The faces make up the final geometry if they
     * are not discarded by the alpha filter. Tweaking the alpha parameter
     * will result in a different (possibly more desired) geometry.
     */
    if (tri->len > 4)
        construct_concave_hull(points, npoints, tri, mp, alpha);

    /*
     * After generating an internal representation of the concave hull this
     * will have to be converted to the lwgeom representation so that it can
     * be serialized and returned to postgres.
     *
     * Because the concave hull can have multiple polygons everything is put
     * into a multipolygon before giving back any data. The lwgeom multipolygon
     * consists of a geometry collection with every geometry type being a
     * basic polygon. These polygons are generated by placing all the internal
     * point pairs into a POINTARRAY as this is the backbone of a lwgeom.
     */
    lwmpoly = lwmpoly_construct_empty(srid, 0, 0);

    for (i = 0; i < mp->len; i++) {
        /* Use lwalloc because lwpoly_construct reuses the pointer */
        POINTARRAY **pas = lwalloc(sizeof(POINTARRAY *) * mp->poly[i].rings);

        for (j = 0; j < mp->poly[i].rings; j++) {
            pas[j] = ptarray_construct_empty(0, 0, 0);

            for (k = mp->poly[i].index[j]; k < mp->poly[i].index[j+1]; k++) {
                p.x = mp->poly[i].pt[k].x;
                p.y = mp->poly[i].pt[k].y;

                ptarray_insert_point(pas[j], &p, pas[j]->npoints);
            }
        }

        lwpoly = lwpoly_construct(srid, NULL, mp->poly[i].rings, pas);
        lwmpoly_add_lwpoly(lwmpoly, lwpoly);
    }

    /* Serialize the final geometry so that we can hand it over to postgres */
    result = gserialized_from_lwgeom(lwmpoly_as_lwgeom(lwmpoly), &ret_size);
    SET_VARSIZE(result, ret_size);

    /* Free the lwmpoly */
    lwmpoly_free(lwmpoly);

    PG_RETURN_POINTER(result);
}

PG_FUNCTION_INFO_V1(concave_hull_finalfn);
Datum concave_hull_finalfn(PG_FUNCTION_ARGS) {
    Datum geometry_array = 0;
    Datum result = 0;
    int dims[1];
    int lbs[1];
    pgis_abs *p;

    if (PG_ARGISNULL(0))
        PG_RETURN_NULL();

    /*
     * We are hijacking a postgis geometry struct for the aggregate
     * functionality. The struct that is used for geometry transfers
     * is not a public struct though, so we recreate it locally to be
     * able to extract the array data.
     */
    p = (pgis_abs *) PG_GETARG_POINTER(0);

    /* Create a datum from the geometry array */
    dims[0] = p->a->nelems;
    lbs[0] = 1;
    geometry_array = makeMdArrayResult(p->a, 1, dims, lbs, CurrentMemoryContext, false);

    /*
     * Only support calling a fixed alpha from the aggregate function because we
     * cannot add another argument to the aggregate wrapper. The main function
     * should be called directly with a geometery array if the caller wants to use
     * a custom alpha value.
     */
    result = DirectFunctionCall2(concave_hull, geometry_array, Float8GetDatum(1.0));

    if (! result)
        PG_RETURN_NULL();

    PG_RETURN_DATUM(result);
}
